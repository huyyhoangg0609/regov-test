"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndySdkSovDidRegistrar = void 0;
const core_1 = require("@aries-framework/core");
const error_1 = require("../error");
const indyError_1 = require("../error/indyError");
const ledger_1 = require("../ledger");
const types_1 = require("../types");
const assertIndySdkWallet_1 = require("../utils/assertIndySdkWallet");
const didSovUtil_1 = require("./didSovUtil");
let IndySdkSovDidRegistrar = class IndySdkSovDidRegistrar {
    constructor(didRepository, indySdkPoolService, indySdk) {
        this.supportedMethods = ['sov'];
        this.didRepository = didRepository;
        this.indySdk = indySdk;
        this.indySdkPoolService = indySdkPoolService;
    }
    async create(agentContext, options) {
        var _a, _b;
        const { alias, role, submitterDid, indyNamespace } = options.options;
        const seed = (_a = options.secret) === null || _a === void 0 ? void 0 : _a.seed;
        if (seed && (typeof seed !== 'string' || seed.length !== 32)) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: 'Invalid seed provided',
                },
            };
        }
        if (!submitterDid.startsWith('did:sov:')) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: 'Submitter did must be a valid did:sov did',
                },
            };
        }
        try {
            // NOTE: we need to use the createAndStoreMyDid method from indy to create the did
            // If we just create a key and handle the creating of the did ourselves, indy will throw a
            // WalletItemNotFound when it needs to sign ledger transactions using this did. This means we need
            // to rely directly on the indy SDK, as we don't want to expose a createDid method just for.
            (0, assertIndySdkWallet_1.assertIndySdkWallet)(agentContext.wallet);
            const [unqualifiedIndyDid, verkey] = await this.indySdk.createAndStoreMyDid(agentContext.wallet.handle, {
                seed,
            });
            const qualifiedSovDid = `did:sov:${unqualifiedIndyDid}`;
            const unqualifiedSubmitterDid = submitterDid.replace('did:sov:', '');
            // TODO: it should be possible to pass the pool used for writing to the indy ledger service.
            // The easiest way to do this would be to make the submitterDid a fully qualified did, including the indy namespace.
            const pool = this.indySdkPoolService.getPoolForNamespace(indyNamespace);
            await this.registerPublicDid(agentContext, unqualifiedSubmitterDid, unqualifiedIndyDid, verkey, alias, pool, role);
            // Create did document
            const didDocumentBuilder = (0, didSovUtil_1.sovDidDocumentFromDid)(qualifiedSovDid, verkey);
            // Add services if endpoints object was passed.
            if (options.options.endpoints) {
                await this.setEndpointsForDid(agentContext, unqualifiedIndyDid, options.options.endpoints, pool);
                (0, didSovUtil_1.addServicesFromEndpointsAttrib)(didDocumentBuilder, qualifiedSovDid, options.options.endpoints, `${qualifiedSovDid}#key-agreement-1`);
            }
            // Build did document.
            const didDocument = didDocumentBuilder.build();
            const didIndyNamespace = pool.config.indyNamespace;
            const qualifiedIndyDid = `did:indy:${didIndyNamespace}:${unqualifiedIndyDid}`;
            // Save the did so we know we created it and can issue with it
            const didRecord = new core_1.DidRecord({
                id: qualifiedSovDid,
                did: qualifiedSovDid,
                role: core_1.DidDocumentRole.Created,
                tags: {
                    recipientKeyFingerprints: didDocument.recipientKeys.map((key) => key.fingerprint),
                    qualifiedIndyDid,
                },
            });
            await this.didRepository.save(agentContext, didRecord);
            return {
                didDocumentMetadata: {
                    qualifiedIndyDid,
                },
                didRegistrationMetadata: {
                    didIndyNamespace,
                },
                didState: {
                    state: 'finished',
                    did: qualifiedSovDid,
                    didDocument,
                    secret: {
                        // FIXME: the uni-registrar creates the seed in the registrar method
                        // if it doesn't exist so the seed can always be returned. Currently
                        // we can only return it if the seed was passed in by the user. Once
                        // we have a secure method for generating seeds we should use the same
                        // approach
                        seed: (_b = options.secret) === null || _b === void 0 ? void 0 : _b.seed,
                    },
                },
            };
        }
        catch (error) {
            return {
                didDocumentMetadata: {},
                didRegistrationMetadata: {},
                didState: {
                    state: 'failed',
                    reason: `unknownError: ${error.message}`,
                },
            };
        }
    }
    async update() {
        return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
                state: 'failed',
                reason: `notImplemented: updating did:sov not implemented yet`,
            },
        };
    }
    async deactivate() {
        return {
            didDocumentMetadata: {},
            didRegistrationMetadata: {},
            didState: {
                state: 'failed',
                reason: `notImplemented: deactivating did:sov not implemented yet`,
            },
        };
    }
    async registerPublicDid(agentContext, submitterDid, targetDid, verkey, alias, pool, role) {
        try {
            agentContext.config.logger.debug(`Register public did '${targetDid}' on ledger '${pool.didIndyNamespace}'`);
            const request = await this.indySdk.buildNymRequest(submitterDid, targetDid, verkey, alias, role || null);
            const response = await this.indySdkPoolService.submitWriteRequest(agentContext, pool, request, submitterDid);
            agentContext.config.logger.debug(`Registered public did '${targetDid}' on ledger '${pool.didIndyNamespace}'`, {
                response,
            });
            return targetDid;
        }
        catch (error) {
            agentContext.config.logger.error(`Error registering public did '${targetDid}' on ledger '${pool.didIndyNamespace}'`, {
                error,
                submitterDid,
                targetDid,
                verkey,
                alias,
                role,
                pool: pool.didIndyNamespace,
            });
            throw error;
        }
    }
    async setEndpointsForDid(agentContext, did, endpoints, pool) {
        try {
            agentContext.config.logger.debug(`Set endpoints for did '${did}' on ledger '${pool.didIndyNamespace}'`, endpoints);
            const request = await this.indySdk.buildAttribRequest(did, did, null, { endpoint: endpoints }, null);
            const response = await this.indySdkPoolService.submitWriteRequest(agentContext, pool, request, did);
            agentContext.config.logger.debug(`Successfully set endpoints for did '${did}' on ledger '${pool.didIndyNamespace}'`, {
                response,
                endpoints,
            });
        }
        catch (error) {
            agentContext.config.logger.error(`Error setting endpoints for did '${did}' on ledger '${pool.didIndyNamespace}'`, {
                error,
                did,
                endpoints,
            });
            throw (0, indyError_1.isIndyError)(error) ? new error_1.IndySdkError(error) : error;
        }
    }
};
IndySdkSovDidRegistrar = __decorate([
    (0, core_1.injectable)(),
    __param(2, (0, core_1.inject)(types_1.IndySdkSymbol)),
    __metadata("design:paramtypes", [core_1.DidRepository,
        ledger_1.IndySdkPoolService, Object])
], IndySdkSovDidRegistrar);
exports.IndySdkSovDidRegistrar = IndySdkSovDidRegistrar;
//# sourceMappingURL=IndySdkSovDidRegistrar.js.map