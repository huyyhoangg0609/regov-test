import type { IndySdkPoolConfig } from './IndySdkPool';
import type { AgentContext } from '@aries-framework/core';
import type { GetNymResponse, LedgerReadReplyResponse, LedgerRequest, LedgerWriteReplyResponse } from 'indy-sdk';
import { Logger, FileSystem } from '@aries-framework/core';
import { Subject } from 'rxjs';
import { IndySdk } from '../types';
import { IndySdkPool } from './IndySdkPool';
export interface CachedDidResponse {
    nymResponse: GetNymResponse;
    poolId: string;
}
export declare class IndySdkPoolService {
    pools: IndySdkPool[];
    private logger;
    private indySdk;
    private stop$;
    private fileSystem;
    constructor(indySdk: IndySdk, logger: Logger, stop$: Subject<boolean>, fileSystem: FileSystem);
    setPools(poolConfigs: IndySdkPoolConfig[]): void;
    /**
     * Create connections to all ledger pools
     */
    connectToPools(): Promise<number[]>;
    /**
     * Get the most appropriate pool for the given did. The algorithm is based on the approach as described in this document:
     * https://docs.google.com/document/d/109C_eMsuZnTnYe2OAd02jAts1vC4axwEKIq7_4dnNVA/edit
     */
    getPoolForDid(agentContext: AgentContext, did: string): Promise<{
        pool: IndySdkPool;
        did: GetNymResponse;
    }>;
    private getSettledDidResponsesFromPools;
    /**
     * Get the most appropriate pool for the given indyNamespace
     */
    getPoolForNamespace(indyNamespace?: string): IndySdkPool;
    submitWriteRequest(agentContext: AgentContext, pool: IndySdkPool, request: LedgerRequest, signDid: string): Promise<LedgerWriteReplyResponse>;
    submitReadRequest(pool: IndySdkPool, request: LedgerRequest): Promise<LedgerReadReplyResponse>;
    private signRequest;
    private appendTaa;
    private getTransactionAuthorAgreement;
    private getDidFromPool;
}
export interface PublicDidRequest {
    did: GetNymResponse;
    pool: IndySdkPool;
    response: LedgerReadReplyResponse;
}
