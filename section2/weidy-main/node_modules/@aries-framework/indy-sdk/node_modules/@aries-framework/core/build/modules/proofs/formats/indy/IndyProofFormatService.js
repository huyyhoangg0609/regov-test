"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndyProofFormatService = void 0;
const Attachment_1 = require("../../../../decorators/attachment/Attachment");
const AriesFrameworkError_1 = require("../../../../error/AriesFrameworkError");
const JsonEncoder_1 = require("../../../../utils/JsonEncoder");
const JsonTransformer_1 = require("../../../../utils/JsonTransformer");
const MessageValidator_1 = require("../../../../utils/MessageValidator");
const credentials_1 = require("../../../credentials");
const IndyCredentialUtils_1 = require("../../../credentials/formats/indy/IndyCredentialUtils");
const indy_1 = require("../../../indy");
const ledger_1 = require("../../../ledger");
const ProofFormatSpec_1 = require("../../models/ProofFormatSpec");
const InvalidEncodedValueError_1 = require("./errors/InvalidEncodedValueError");
const models_1 = require("./models");
const PartialProof_1 = require("./models/PartialProof");
const ProofRequest_1 = require("./models/ProofRequest");
const RequestedCredentials_1 = require("./models/RequestedCredentials");
const util_1 = require("./util");
const sortRequestedCredentials_1 = require("./util/sortRequestedCredentials");
const V2_INDY_PRESENTATION_PROPOSAL = 'hlindy/proof-req@v2.0';
const V2_INDY_PRESENTATION_REQUEST = 'hlindy/proof-req@v2.0';
const V2_INDY_PRESENTATION = 'hlindy/proof@v2.0';
class IndyProofFormatService {
    constructor() {
        this.formatKey = 'indy';
    }
    async createProposal(agentContext, { attachmentId, proofFormats }) {
        var _a, _b, _c, _d;
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            format: V2_INDY_PRESENTATION_PROPOSAL,
            attachmentId,
        });
        const indyFormat = proofFormats.indy;
        if (!indyFormat) {
            throw Error('Missing indy format to create proposal attachment format');
        }
        const proofRequest = (0, util_1.createRequestFromPreview)({
            attributes: (_a = indyFormat.attributes) !== null && _a !== void 0 ? _a : [],
            predicates: (_b = indyFormat.predicates) !== null && _b !== void 0 ? _b : [],
            name: (_c = indyFormat.name) !== null && _c !== void 0 ? _c : 'Proof request',
            version: (_d = indyFormat.version) !== null && _d !== void 0 ? _d : '1.0',
            nonce: await agentContext.wallet.generateNonce(),
        });
        const attachment = this.getFormatData(proofRequest.toJSON(), format.attachmentId);
        return { attachment, format };
    }
    async processProposal(agentContext, { attachment }) {
        const proposalJson = attachment.getDataAsJson();
        // fromJSON also validates
        const proposal = JsonTransformer_1.JsonTransformer.fromJSON(proposalJson, ProofRequest_1.ProofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, util_1.assertNoDuplicateGroupsNamesInProofRequest)(proposal);
    }
    async acceptProposal(agentContext, { proposalAttachment, attachmentId }) {
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            format: V2_INDY_PRESENTATION_REQUEST,
            attachmentId,
        });
        const proposalJson = proposalAttachment.getDataAsJson();
        // The proposal and request formats are the same, so we can just use the proposal
        const request = JsonTransformer_1.JsonTransformer.fromJSON(proposalJson, ProofRequest_1.ProofRequest);
        // We never want to reuse the nonce from the proposal, as this will allow replay attacks
        request.nonce = await agentContext.wallet.generateNonce();
        const attachment = this.getFormatData(request.toJSON(), format.attachmentId);
        return { attachment, format };
    }
    async createRequest(agentContext, { attachmentId, proofFormats }) {
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            format: V2_INDY_PRESENTATION_REQUEST,
            attachmentId,
        });
        const indyFormat = proofFormats.indy;
        if (!indyFormat) {
            throw Error('Missing indy format in create request attachment format');
        }
        const request = new ProofRequest_1.ProofRequest({
            name: indyFormat.name,
            version: indyFormat.version,
            nonce: await agentContext.wallet.generateNonce(),
            requestedAttributes: indyFormat.requestedAttributes,
            requestedPredicates: indyFormat.requestedPredicates,
            nonRevoked: indyFormat.nonRevoked,
        });
        // Validate to make sure user provided correct input
        MessageValidator_1.MessageValidator.validateSync(request);
        (0, util_1.assertNoDuplicateGroupsNamesInProofRequest)(request);
        const attachment = this.getFormatData(request.toJSON(), format.attachmentId);
        return { attachment, format };
    }
    async processRequest(agentContext, { attachment }) {
        const requestJson = attachment.getDataAsJson();
        // fromJSON also validates
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(requestJson, ProofRequest_1.ProofRequest);
        // Assert attribute and predicate (group) names do not match
        (0, util_1.assertNoDuplicateGroupsNamesInProofRequest)(proofRequest);
    }
    async acceptRequest(agentContext, { proofFormats, requestAttachment, attachmentId }) {
        const format = new ProofFormatSpec_1.ProofFormatSpec({
            format: V2_INDY_PRESENTATION,
            attachmentId,
        });
        const indyFormat = proofFormats === null || proofFormats === void 0 ? void 0 : proofFormats.indy;
        const requestJson = requestAttachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(requestJson, ProofRequest_1.ProofRequest);
        let requestedCredentials;
        if (indyFormat) {
            requestedCredentials = new RequestedCredentials_1.RequestedCredentials({
                requestedAttributes: indyFormat.requestedAttributes,
                requestedPredicates: indyFormat.requestedPredicates,
                selfAttestedAttributes: indyFormat.selfAttestedAttributes,
            });
            // Validate to make sure user provided correct input
            MessageValidator_1.MessageValidator.validateSync(requestedCredentials);
        }
        else {
            const selectedCredentials = await this._selectCredentialsForRequest(agentContext, proofRequest, {
                filterByNonRevocationRequirements: true,
            });
            requestedCredentials = new RequestedCredentials_1.RequestedCredentials({
                requestedAttributes: selectedCredentials.requestedAttributes,
                requestedPredicates: selectedCredentials.requestedPredicates,
                selfAttestedAttributes: selectedCredentials.selfAttestedAttributes,
            });
        }
        const proof = await this.createProof(agentContext, proofRequest, requestedCredentials);
        const attachment = this.getFormatData(proof, format.attachmentId);
        return {
            attachment,
            format,
        };
    }
    async processPresentation(agentContext, { requestAttachment, attachment }) {
        const indyVerifierService = agentContext.dependencyManager.resolve(indy_1.IndyVerifierService);
        const proofRequestJson = requestAttachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        const proofJson = attachment.getDataAsJson();
        const proof = JsonTransformer_1.JsonTransformer.fromJSON(proofJson, PartialProof_1.PartialProof);
        for (const [referent, attribute] of proof.requestedProof.revealedAttributes.entries()) {
            if (!IndyCredentialUtils_1.IndyCredentialUtils.checkValidEncoding(attribute.raw, attribute.encoded)) {
                throw new InvalidEncodedValueError_1.InvalidEncodedValueError(`The encoded value for '${referent}' is invalid. ` +
                    `Expected '${IndyCredentialUtils_1.IndyCredentialUtils.encode(attribute.raw)}'. ` +
                    `Actual '${attribute.encoded}'`);
            }
        }
        // TODO: pre verify proof json
        // I'm not 100% sure how much indy does. Also if it checks whether the proof requests matches the proof
        // @see https://github.com/hyperledger/aries-cloudagent-python/blob/master/aries_cloudagent/indy/sdk/verifier.py#L79-L164
        const schemas = await this.getSchemas(agentContext, new Set(proof.identifiers.map((i) => i.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(agentContext, new Set(proof.identifiers.map((i) => i.credentialDefinitionId)));
        return await indyVerifierService.verifyProof(agentContext, {
            proofRequest: proofRequest.toJSON(),
            proof: proofJson,
            schemas,
            credentialDefinitions,
        });
    }
    async getCredentialsForRequest(agentContext, { requestAttachment, proofFormats }) {
        var _a;
        const proofRequestJson = requestAttachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        // Set default values
        const { filterByNonRevocationRequirements = true } = (_a = proofFormats === null || proofFormats === void 0 ? void 0 : proofFormats.indy) !== null && _a !== void 0 ? _a : {};
        const credentialsForRequest = await this._getCredentialsForRequest(agentContext, proofRequest, {
            filterByNonRevocationRequirements,
        });
        return credentialsForRequest;
    }
    async selectCredentialsForRequest(agentContext, { requestAttachment, proofFormats }) {
        var _a;
        const proofRequestJson = requestAttachment.getDataAsJson();
        const proofRequest = JsonTransformer_1.JsonTransformer.fromJSON(proofRequestJson, ProofRequest_1.ProofRequest);
        // Set default values
        const { filterByNonRevocationRequirements = true } = (_a = proofFormats === null || proofFormats === void 0 ? void 0 : proofFormats.indy) !== null && _a !== void 0 ? _a : {};
        const selectedCredentials = this._selectCredentialsForRequest(agentContext, proofRequest, {
            filterByNonRevocationRequirements,
        });
        return selectedCredentials;
    }
    async shouldAutoRespondToProposal(agentContext, { proposalAttachment, requestAttachment }) {
        const proposalJson = proposalAttachment.getDataAsJson();
        const requestJson = requestAttachment.getDataAsJson();
        const areRequestsEqual = (0, util_1.areIndyProofRequestsEqual)(proposalJson, requestJson);
        agentContext.config.logger.debug(`Indy request and proposal are are equal: ${areRequestsEqual}`, {
            proposalJson,
            requestJson,
        });
        return areRequestsEqual;
    }
    async shouldAutoRespondToRequest(agentContext, { proposalAttachment, requestAttachment }) {
        const proposalJson = proposalAttachment.getDataAsJson();
        const requestJson = requestAttachment.getDataAsJson();
        return (0, util_1.areIndyProofRequestsEqual)(proposalJson, requestJson);
    }
    async shouldAutoRespondToPresentation() {
        // The presentation is already verified in processPresentation, so we can just return true here.
        // It's only an ack, so it's just that we received the presentation.
        return true;
    }
    supportsFormat(formatIdentifier) {
        const supportedFormats = [V2_INDY_PRESENTATION_PROPOSAL, V2_INDY_PRESENTATION_REQUEST, V2_INDY_PRESENTATION];
        return supportedFormats.includes(formatIdentifier);
    }
    async _getCredentialsForRequest(agentContext, proofRequest, options) {
        const credentialsForProofRequest = {
            attributes: {},
            predicates: {},
        };
        const proofRequestJson = proofRequest.toJSON();
        for (const [referent, requestedAttribute] of proofRequest.requestedAttributes.entries()) {
            const credentials = await this.getCredentialsForProofRequestReferent(agentContext, proofRequestJson, referent);
            credentialsForProofRequest.attributes[referent] = (0, sortRequestedCredentials_1.sortRequestedCredentials)(await Promise.all(credentials.map(async (credential) => {
                const { revoked, deltaTimestamp } = await this.getRevocationStatusForRequestedItem(agentContext, {
                    proofRequest,
                    requestedItem: requestedAttribute,
                    credential,
                });
                return new models_1.RequestedAttribute({
                    credentialId: credential.credentialInfo.referent,
                    revealed: true,
                    credentialInfo: credential.credentialInfo,
                    timestamp: deltaTimestamp,
                    revoked,
                });
            })));
            // We only attach revoked state if non-revocation is requested. So if revoked is true it means
            // the credential is not applicable to the proof request
            if (options.filterByNonRevocationRequirements) {
                credentialsForProofRequest.attributes[referent] = credentialsForProofRequest.attributes[referent].filter((r) => !r.revoked);
            }
        }
        for (const [referent, requestedPredicate] of proofRequest.requestedPredicates.entries()) {
            const credentials = await this.getCredentialsForProofRequestReferent(agentContext, proofRequestJson, referent);
            credentialsForProofRequest.predicates[referent] = (0, sortRequestedCredentials_1.sortRequestedCredentials)(await Promise.all(credentials.map(async (credential) => {
                const { revoked, deltaTimestamp } = await this.getRevocationStatusForRequestedItem(agentContext, {
                    proofRequest,
                    requestedItem: requestedPredicate,
                    credential,
                });
                return new models_1.RequestedPredicate({
                    credentialId: credential.credentialInfo.referent,
                    credentialInfo: credential.credentialInfo,
                    timestamp: deltaTimestamp,
                    revoked,
                });
            })));
            // We only attach revoked state if non-revocation is requested. So if revoked is true it means
            // the credential is not applicable to the proof request
            if (options.filterByNonRevocationRequirements) {
                credentialsForProofRequest.predicates[referent] = credentialsForProofRequest.predicates[referent].filter((r) => !r.revoked);
            }
        }
        return credentialsForProofRequest;
    }
    async _selectCredentialsForRequest(agentContext, proofRequest, options) {
        const credentialsForRequest = await this._getCredentialsForRequest(agentContext, proofRequest, options);
        const selectedCredentials = {
            requestedAttributes: {},
            requestedPredicates: {},
            selfAttestedAttributes: {},
        };
        Object.keys(credentialsForRequest.attributes).forEach((attributeName) => {
            const attributeArray = credentialsForRequest.attributes[attributeName];
            if (attributeArray.length === 0) {
                throw new AriesFrameworkError_1.AriesFrameworkError('Unable to automatically select requested attributes.');
            }
            selectedCredentials.requestedAttributes[attributeName] = attributeArray[0];
        });
        Object.keys(credentialsForRequest.predicates).forEach((attributeName) => {
            if (credentialsForRequest.predicates[attributeName].length === 0) {
                throw new AriesFrameworkError_1.AriesFrameworkError('Unable to automatically select requested predicates.');
            }
            else {
                selectedCredentials.requestedPredicates[attributeName] = credentialsForRequest.predicates[attributeName][0];
            }
        });
        return selectedCredentials;
    }
    async getCredentialsForProofRequestReferent(agentContext, 
    // pass as json to prevent having to transform to json on every call
    proofRequestJson, attributeReferent) {
        const holderService = agentContext.dependencyManager.resolve(indy_1.IndyHolderService);
        const credentialsJson = await holderService.getCredentialsForProofRequest(agentContext, {
            proofRequest: proofRequestJson,
            attributeReferent,
        });
        return JsonTransformer_1.JsonTransformer.fromJSON(credentialsJson, credentials_1.IndyCredential);
    }
    /**
     * Build schemas object needed to create and verify proof objects.
     *
     * Creates object with `{ schemaId: Schema }` mapping
     *
     * @param schemaIds List of schema ids
     * @returns Object containing schemas for specified schema ids
     *
     */
    async getSchemas(agentContext, schemaIds) {
        const ledgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const schemas = {};
        for (const schemaId of schemaIds) {
            const schema = await ledgerService.getSchema(agentContext, schemaId);
            schemas[schemaId] = schema;
        }
        return schemas;
    }
    /**
     * Build credential definitions object needed to create and verify proof objects.
     *
     * Creates object with `{ credentialDefinitionId: CredentialDefinition }` mapping
     *
     * @param credentialDefinitionIds List of credential definition ids
     * @returns Object containing credential definitions for specified credential definition ids
     *
     */
    async getCredentialDefinitions(agentContext, credentialDefinitionIds) {
        const ledgerService = agentContext.dependencyManager.resolve(ledger_1.IndyLedgerService);
        const credentialDefinitions = {};
        for (const credDefId of credentialDefinitionIds) {
            const credDef = await ledgerService.getCredentialDefinition(agentContext, credDefId);
            credentialDefinitions[credDefId] = credDef;
        }
        return credentialDefinitions;
    }
    /**
     * Create indy proof from a given proof request and requested credential object.
     *
     * @param proofRequest The proof request to create the proof for
     * @param requestedCredentials The requested credentials object specifying which credentials to use for the proof
     * @returns indy proof object
     */
    async createProof(agentContext, proofRequest, requestedCredentials) {
        const indyHolderService = agentContext.dependencyManager.resolve(indy_1.IndyHolderService);
        const credentialObjects = await Promise.all([
            ...Object.values(requestedCredentials.requestedAttributes),
            ...Object.values(requestedCredentials.requestedPredicates),
        ].map(async (c) => {
            if (c.credentialInfo) {
                return c.credentialInfo;
            }
            const credentialInfo = await indyHolderService.getCredential(agentContext, c.credentialId);
            return JsonTransformer_1.JsonTransformer.fromJSON(credentialInfo, credentials_1.IndyCredentialInfo);
        }));
        const schemas = await this.getSchemas(agentContext, new Set(credentialObjects.map((c) => c.schemaId)));
        const credentialDefinitions = await this.getCredentialDefinitions(agentContext, new Set(credentialObjects.map((c) => c.credentialDefinitionId)));
        return await indyHolderService.createProof(agentContext, {
            proofRequest: proofRequest.toJSON(),
            requestedCredentials: requestedCredentials,
            schemas,
            credentialDefinitions,
        });
    }
    async getRevocationStatusForRequestedItem(agentContext, { proofRequest, requestedItem, credential, }) {
        var _a;
        const indyRevocationService = agentContext.dependencyManager.resolve(indy_1.IndyRevocationService);
        const requestNonRevoked = (_a = requestedItem.nonRevoked) !== null && _a !== void 0 ? _a : proofRequest.nonRevoked;
        const credentialRevocationId = credential.credentialInfo.credentialRevocationId;
        const revocationRegistryId = credential.credentialInfo.revocationRegistryId;
        // If revocation interval is present and the credential is revocable then fetch the revocation status of credentials for display
        if (requestNonRevoked && credentialRevocationId && revocationRegistryId) {
            agentContext.config.logger.trace(`Presentation is requesting proof of non revocation, getting revocation status for credential`, {
                requestNonRevoked,
                credentialRevocationId,
                revocationRegistryId,
            });
            // Note presentation from-to's vs ledger from-to's: https://github.com/hyperledger/indy-hipe/blob/master/text/0011-cred-revocation/README.md#indy-node-revocation-registry-intervals
            const status = await indyRevocationService.getRevocationStatus(agentContext, credentialRevocationId, revocationRegistryId, requestNonRevoked);
            return status;
        }
        return { revoked: undefined, deltaTimestamp: undefined };
    }
    /**
     * Returns an object of type {@link Attachment} for use in credential exchange messages.
     * It looks up the correct format identifier and encodes the data as a base64 attachment.
     *
     * @param data The data to include in the attach object
     * @param id the attach id from the formats component of the message
     */
    getFormatData(data, id) {
        const attachment = new Attachment_1.Attachment({
            id,
            mimeType: 'application/json',
            data: new Attachment_1.AttachmentData({
                base64: JsonEncoder_1.JsonEncoder.toBase64(data),
            }),
        });
        return attachment;
    }
}
exports.IndyProofFormatService = IndyProofFormatService;
//# sourceMappingURL=IndyProofFormatService.js.map